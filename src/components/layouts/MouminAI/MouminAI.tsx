"use client"

/**
 * This code was generated by Builder.io.
 */
import React, { useState, useEffect, useRef } from 'react';
import ProfileSection from "./ProfileSection";
import SuggestedQuestions from "./SuggestedQuestions";
import InputSection, { InputSectionRef } from "./InputSection";
import ChatMessage from '@/components/chat/ChatMessage';
import useLocalStorage from './sessionId';
import ChatHistory from './ChatHistory';
import { v4 as uuidv4 } from 'uuid';
import { API_URL } from "@/config";
import {
  Modal,
  Button,
  Text,
  Textarea,
  Flex,
  Drawer,
} from "rizzui";

const MouminAI: React.FC = () => {

  const [systemHealth, setSystemHealth] = useState<'loading' | 'healthy' | 'overloaded'>('loading');
  const bottomRef = useRef(null);
  // const [responseData, setResponseData] = useState(null);
  const [messages, setMessages] = useState([])
  const [sessionId, setSessionId] = useLocalStorage('sessionId', '');
  const [conversations, setConversations] = useState([])
  const  [conversation_id] = useState(uuidv4());
  const [modalState, setModalState] = useState(false);

  const [drawerState, setDrawerState] = useState(false);

  const [currentTraceId, setTraceId] = useState(null)
  const [traceCommentText, setTraceCommentText] = useState(undefined)

  const inputSectionRef = useRef<InputSectionRef>(null);

  const scrollToBottom = () => {
    const container = bottomRef.current;
    container.scrollTop = container.scrollHeight;
  };

  useEffect(() => {
    const checkHealth = async () => {
      try {
        const response = await fetch(`${API_URL}/health`);
        if (!response.ok) {
          throw new Error('Health check failed');
        }
        const data = await response.json();
        setSystemHealth(data.status);
      } catch (error) {
        console.error('Health check error:', error);
        setSystemHealth('overloaded');
      }
    };

    // Initial check
    checkHealth();

    // Set up periodic health checks every 30 seconds
    const intervalId = setInterval(checkHealth, 600000);

    // Cleanup interval on component unmount
    return () => clearInterval(intervalId);
  }, []);

  const submitComment = async () => {

    if (traceCommentText == undefined || traceCommentText == ""){
      setModalState(false)
      return
    }

    try {

      const response = await fetch(`${API_URL}/add-comment`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          "trace_id": currentTraceId,
          "comment": traceCommentText
         }),
      });

      if (!response.ok) {
        throw new Error('Something went wrong');
      }
      
      setTraceCommentText(undefined)
      setTraceId(null)
      setModalState(false)

      // Handle response data here
    } catch (error) {
      console.error('Error:', error);
      // Handle error here
    }

  }

  const askQuestion = async (text: string) => {
    if (inputSectionRef.current) {
      await inputSectionRef.current.submitQuestion(text);
    }
  };

  // Handle sessionId initialization
  useEffect(() => {
      if (!sessionId) {
        setSessionId(uuidv4());
      }
  }, []); // Empty dependency array so it only runs once
  
  useEffect(() => {

    if (!sessionId) return; // Skip if sessionId is not yet set

    const getData = async () => {

      try {
             
        const response = await fetch(`${API_URL}/conversations`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ 
            "sessionId": sessionId,
           }),
        });
  
  
        if (!response.ok) {
          throw new Error('Something went wrong');
        }
  
        const data = await response.json();
        
        setConversations(JSON.parse(data))

        // Handle response data here
      } catch (error) {
       
        console.error('Error:', error);
        // Handle error here
      }

      
    }

    getData()
    
  }, [sessionId])

  const addFeedback = async (itemIndex : Number, score : Number) => {

    let item = messages[itemIndex]

    try {
     
      const response = await fetch(`${API_URL}/feedback`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          "feedback_value": score,
          "trace_id": item.trace_id
         }),
      });


      if (!response.ok) {
        throw new Error('Something went wrong');
      }

      const data = await response.json();

      const updatedMessages = messages.map((message, idx) => {
        if (idx === itemIndex) {
          return { ...message, feedback: score }; // Increase the likes for the clicked message
        }
        return message; // Return the rest of the messages unchanged
      });

      if (score == 0){
        setModalState(true)
        setTraceId(item.trace_id)  
      }
     
      // Update the state with the new array
      setMessages(updatedMessages);

      console.log(data)
      // Handle response data here
    } catch (error) {
     
      console.error('Error:', error);
      // Handle error here
    }

  }

  const handleFormSubmit = (data: any) => {

    if (data.status === "user") {
      setMessages([...messages, data, { status: 'sending' }]);
    } else if (data.status == "action"){

      setMessages((prevMessages) => {
        const updatedMessages = [...prevMessages];
        
        updatedMessages[updatedMessages.length - 1] = {
          status: "action",
          content: data.content,
          isStreaming: false,
        };
        
        return updatedMessages;
      });

    } else if (data.status == "error"){

      setMessages((prevMessages) => {
        const updatedMessages = [...prevMessages];
        
        updatedMessages[updatedMessages.length - 1] = {
          status: "error",
          isStreaming: false,
        };
        
        return updatedMessages;
      });

    } else if (data.status == "stopped"){

      setMessages((prevMessages) => {
        const updatedMessages = [...prevMessages];
        const lastMessage = updatedMessages[updatedMessages.length - 1];

        if (lastMessage.status == "action" || lastMessage.status == "sending") {
          updatedMessages[updatedMessages.length - 1] = {
            status: "stopped",
            isStreaming: false,
          };
        } else {
          updatedMessages[updatedMessages.length - 1] = {
            status: "assistant",
            isStreaming: false,
            content: lastMessage.content,
          };
        }
        
        return updatedMessages;
      });

    } else if (data.status === "assistant") {
      setMessages((prevMessages) => {
        const updatedMessages = [...prevMessages];
        const lastMessage = updatedMessages[updatedMessages.length - 1];
        
        if (lastMessage.status === "assistant") {
          lastMessage.content = data.content;
          lastMessage.isStreaming = data.isStreaming;
          if (!data.isStreaming) {
            lastMessage.executionTime = data.executionTime;
            lastMessage.trace_id = data.trace_id;
          }
        } else {
          updatedMessages[updatedMessages.length - 1] = {
            status: "assistant",
            content: data.content,
            isStreaming: data.isStreaming,
            executionTime: data.executionTime,
            trace_id: data.trace_id
          };
        }
        
        return updatedMessages;
      });
    }
    setTimeout(scrollToBottom, 100);
  };

  // useEffect(() => {
  //   if (responseData) {
  //     if (responseData.status == "user"){
  //       setMessages([...messages, responseData, {status: 'sending'}])
  //       setTimeout(() => {
  //         scrollToBottom()
  //       }, 100)
  //     }else if (responseData.status == "assistant"){
  //       setMessages((prevMessages) => {
  //         const updatedMessages = [...prevMessages];
  //         updatedMessages[updatedMessages.length - 1] = responseData
  //         return updatedMessages;
  //       });
  //       setTimeout(() => {
  //         scrollToBottom()
  //       }, 100)
  //     }
  //   }
  // }, [responseData]); 


  if (systemHealth === 'loading') {
    return (
      <div className="flex h-screen w-full items-center justify-center bg-neutral-100">
        <div className="text-center">
          <div className="mb-4">
            <svg className="w-12 h-12 animate-spin text-emerald-700 mx-auto" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
            </svg>
          </div>
          <div className="text-lg font-medium text-neutral-900">جاري التحقق من جاهزية النظام...</div>
        </div>
      </div>
    );
  }

  if (systemHealth === 'overloaded') {
    return (
      <div className="flex h-screen w-full items-center justify-center bg-neutral-100">
        <div className="text-center max-w-md px-4">
          <div className="mb-4 text-red-600">
            <svg className="w-16 h-16 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
          </div>
          <div className="text-xl font-medium text-neutral-900 mb-2">النظام غير متاح حالياً</div>
          <div className="text-neutral-600">يرجى المحاولة مرة أخرى لاحقاً. النظام يواجه ضغطاً في الوقت الحالي.</div>
          <Button
            className="mt-4"
            onClick={() => setSystemHealth('loading')}
          >
            إعادة المحاولة
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className='relative flex h-full w-full bg-neutral-100 overflow-hidden transition-colors z-0'>
      
      <Drawer
        isOpen={drawerState}
        onClose={() => setDrawerState(false)}
        customSize={360}
      >
        <div className="z-[1] bg-neutral-100 flex-shrink-0 overflow-x-hidden bg-neutral-100 fixed top-0 right-0 h-full" style={{ "width": "384px" }}>
          <ChatHistory onCloseBtnClicked={() => setDrawerState(false)} conversations={conversations} />
        </div>
      </Drawer>
     

      <div className='relative flex h-full max-w-full flex-1 flex-col overflow-hidden'>
        
        <div className='draggable sticky top-0 z-10 flex min-h-[56px] items-center justify-center border-transparent bg-token-main-surface-primary pl-0 '>
          <ProfileSection onDrawerIconClicked={() => setDrawerState(true)} />
        </div> 
     
    <main className='relative h-full w-full flex-1 overflow-auto transition-width'>
    <div className='composer-parent flex h-full flex-col focus-visible:outline-0'>
      <div className='relative flex max-w-full flex-1 flex-col overflow-hidden'>

          {messages.length == 0 ? (
            <>
              <SuggestedQuestions 
                onQuestionSelect={(question) => askQuestion(question)}
              />
            </>
          ) : (

                  <div ref={bottomRef} className="flex-1 w-full md:max-w-3xl lg:max-w-[40rem] xl:max-w-[48rem] overflow-x-hidden scroll-smooth font-medium self-center text-neutral-900 text-opacity-90">
                    <div className='h-full'>
                      {messages.map((message, index) => (
                        <div  key={index}  className='w-full text-token-text-primary focus-visible:outline-2 focus-visible:outline-offset-[-4px]'>
                          <div className='m-auto text-lg py-[18px] px-3 md:px-4 w-full md:px-5 lg:px-4 xl:px-5'>
                            <ChatMessage
                              sender={message.status}
                              content={message.content}
                              index={index}
                              item={message}
                              addFeedback={addFeedback}
                            />
                          </div>
                        </div>
                      ))}
                      </div>
              </div>

)}
          
          </div>

        <div className='md:pt-0 dark:border-white/20 md:border-transparent md:dark:border-transparent w-full'>
          <InputSection 
            ref={inputSectionRef}
            sessionId={sessionId} 
            onFormSubmit={handleFormSubmit} 
            conversation_id={conversation_id} 
          />
          <div className='text-center text-black text-opacity-50 text-sm my-2'>النموذج مازال في مرحلة الإختبار والتطوير, بعض الإجابات قد تكون غير دقيقة</div>
        </div>

        </div>
    
    </main>

    </div>

    <Modal
        isOpen={modalState}
        onClose={() => setModalState(false)}
      >
        <div className="m-auto px-7 pt-6 pb-8">
          <div className="mb-7 flex items-center justify-between">
            <Text as="h3">يرجى تقديم معلومات اضافية عن سبب التقييم</Text>
          </div>
          <div className='mb-5'>
          <Textarea
            size='lg'
            label="الرسالة"
            value={traceCommentText}
            onChange={(e) => setTraceCommentText(e.target.value)}
            id="comment"
            name="comment"
            placeholder="اكتب شرح عن التقييم"
          />
          </div>

          <Flex justify="center" align="center">
            <Button
                      type="submit"
                      size="md"
                      className="col-span-2 mt-2"
                      onClick={() => submitComment()}
                    >
                      أرسال
                    </Button>
                    <Button
                      variant='outline'
                      type="button"
                      size="md"
                      className="col-span-2 mt-2"
                      onClick={() => setModalState(false)}
                    >
                      الغاء
                    </Button>
            </Flex>
        </div>
      </Modal>

    </div>
  );

};

export default MouminAI;
